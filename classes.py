from datetime import datetime
from operator import itemgetter

from mongoengine import *
from utils import *
from errors import *

StatusChoices = [1, 2, 3, 4, 5, 6]
StatusDescriptions = {
    1: 'unpatched',
    2: 'patched',
    3: 'unaffected',
    4: 'upstream hold',
    5: 'on gerrit',
    6: 'update available'
}
StatusValues = {
    'unpatched': 1,
    'patched': 2,
    'unaffected': 3,
    'upstream hold': 4,
    'on gerrit': 5,
    'update available': 6
}

BranchNames = ['cm-13.0', 'cm-14.1', 'lineage-15.0', 'lineage-15.1']
KernelVersions = ['3.4', '3.10', '3.18', '4.4', '4.9']

DeprecatedMap = {
    -1: [True, False],
    0: [False],
    1: [True]
}

def map_deprecated_values(v):
    if isinstance(v, str):
        try:
            deprecated = int(v)
        except ValidationError:
            deprecated = None
    else:
        deprecated = v

    if deprecated not in DeprecatedMap:
        deprecated = -1

    return DeprecatedMap[deprecated]

class Patchset(EmbeddedDocument):
    versions = ListField(StringField(choices=KernelVersions), required=True)
    patches = ListField(StringField(), required=True)

    @staticmethod
    def validate_version(version):
        if not isinstance(version, str):
            raise InvalidTypeError('Patchset version is not a string.')
        if version not in KernelVersions:
            raise ValidationError('Patchset version "{}" ' \
                    'is invalid.'.format(version))

    @staticmethod
    def validate_patch(patch):
        if not isinstance(patch, str):
            raise InvalidTypeError('Patchset patch is not a string.')
        if not is_valid_url(patch):
            raise ValidationError('Patchset patch "{}" ' \
                    'is an invalid URL.'.format(patch))

    @staticmethod
    def validate_versions(versions):
        if not versions:
            raise IsEmptyError('Patchset versions cannot be empty.')
        if not isinstance(versions, list):
            raise InvalidTypeError('Patchset versions are not a list.')

        for version in versions:
            Patchset.validate_version(version)

    @staticmethod
    def validate_patches(patches):
        if not patches:
            raise IsEmptyError('Patchset patches cannot be empty.')
        if not isinstance(patches, list):
            raise InvalidTypeError('Patchset patches are not a list.')

        for patch in patches:
            Patchset.validate_patch(patch)

    @staticmethod
    def create(data):
        versions = data.get('versions')
        Patchset.validate_versions(versions)

        patches = data.get('patches')
        Patchset.validate_patches(patches)

        patchset = Patchset(versions=versions, patches=patches)

        return patchset

class Cve(Document):
    name = StringField(required=True, primary_key=True)
    notes = StringField(default='')
    score = FloatField(min_value=0, max_value=10, required=True)
    tags = ListField(StringField(), default=[])
    patchsets = EmbeddedDocumentListField(Patchset)

    @staticmethod
    def validate_name(name):
        if not name:
            raise IsEmptyError('CVE name cannot be empty.')
        if not isinstance(name, str):
            raise InvalidTypeError('CVE name is not a string.')
        if name[:3] not in ['CVE', 'LVT']:
            raise ValidationError('CVE name "{}" does not ' \
                    'begin with "CVE" or "LVT".'.format(name))

    @staticmethod
    def validate_notes(notes):
        if not isinstance(notes, str):
            raise ValidationError('CVE notes are not a string.')

    @staticmethod
    def validate_score(score):
        if score is None:
            raise IsEmptyError('CVE score cannot be empty.')
        if not isinstance(score, (int, float)):
            raise InvalidTypeError('CVE score is not a number.')
        if score < 0 or score > 10:
            raise ValidationError('CVE score {} is not ' \
                    'between 0 and 10, inclusive.'.format(score))

    @staticmethod
    def validate_tags(tags):
        if not isinstance(tags, list):
            raise InvalidTypeError('CVE tags are not a list.')
        for tag in tags:
            if not isinstance(tag, str):
                raise InvalidTypeError('CVE tag is not a string.')

    @staticmethod
    def create(data):
        name = data.get('name')
        Cve.validate_name(name)

        notes = data.get('notes', '')
        Cve.validate_notes(notes)

        score = data.get('score', get_cve_score(name))
        Cve.validate_score(score)

        tags = data.get('tags', [])
        Cve.validate_tags(tags)

        patchsets_data = data.get('patchsets', [])
        patchsets = []
        for patchset_data in patchsets_data:
            patchset = Patchset.create(patchset_data)

            patchsets.append(patchset)

        try:
            cve = Cve.objects.get(name=name)
            raise AlreadyExistsError('CVE "{}" already exists.'.format(name))
        except AlreadyExistsError as e:
            raise e
        except DoesNotExist:
            pass

        cve = Cve(name=name, notes=notes, score=score, tags=tags,
                patchsets=patchsets)

        return cve

    def patch(self, data):
        notes = data.get('notes')
        if notes is not None:
            Cve.validate_notes(notes)
            self.notes = notes

        score = data.get('score')
        if score is not None:
            Cve.validate_score(score)
            self.score = score

        tags = data.get('tags')
        if tags is not None:
            Cve.validate_tags(tags)
            self.tags = tags

        patchsets_data = data.get('patchsets')
        if patchsets_data is not None:
            if not patchsets_data:
                raise IsEmptyError('CVE patchsets cannot be empty.')

            patchsets = []
            for patchset_data in patchsets_data:
                patchset = Patchset.create(patchset_data)
                patchsets.append(patchset)

            self.patchsets = patchsets

        return self

    def get_statuses(self, all_branches=False):
        kernels_list = Status.objects(cve=self) \
                .only('kernel', 'branch', 'value')
        statuses = {}
        for status in kernels_list:
            if status.kernel.id not in statuses:
                statuses[status.kernel.id] = {}

            statuses[status.kernel.id][status.branch] = status.value

        if not all_branches:
            return statuses

        kernels = Kernel.objects()
        for kernel in kernels:
            if kernel.repo not in statuses:
                statuses[kernel.repo] = {}

            for branch in kernel.branches:
                if branch.name not in statuses[kernel.repo]:
                    statuses[kernel.repo][branch.name] = \
                            StatusValues['unpatched']

        return statuses

class Branch(EmbeddedDocument):
    name = StringField(required=True, choices=BranchNames)
    version = StringField(required=True, choices=KernelVersions)
    patched_cves = IntField(default=0)
    unaffected_cves = IntField(default=0)
    percentage = IntField()

    @staticmethod
    def validate_name(name):
        if name not in BranchNames:
            raise ValidationError('Branch name "{}" is invalid.'.format(name))

    @staticmethod
    def validate_version(version):
        if version not in KernelVersions:
            raise ValidationError('Branch version "{}" ' \
                    'is invalid.'.format(version))

    @staticmethod
    def name_in(name, branches):
        found_branch = None
        for branch in branches:
            if name == branch.name:
                found_branch = branch
        return found_branch

    @staticmethod
    def validate_name_in(name, branches):
        branch = Branch.name_in(name, branches)
        if not branch:
            raise DoesNotExistError('Branch with name "{}" ' \
                    'does not exist.'.format(name))
        return branch

    @staticmethod
    def validate_name_not_in(name, branches):
        if Branch.name_in(name, branches):
            raise AlreadyExistsError('Branch with name "{}" ' \
                    'already exist.'.format(name))

    @staticmethod
    def create(name, version):
        Branch.validate_name(name)
        Branch.validate_version(version)

        branch = Branch(name=name, version=version)
        return branch

    @staticmethod
    def create_in(name, version, branches):
        Branch.validate_name_not_in(name, branches)
        branch = Branch.create(name, version)
        branches.append(branch)
        return branch

    @staticmethod
    def create_multiple_in(branches_data, branches):
        for branch_data in branches_data:
            name = branch_data.get('name')
            version = branch_data.get('version')
            Branch.create_in(name, version, branches)

    def set_percentage(self, total_cves):
        if self.unaffected_cves == total_cves:
            percentage = 0
        else:
            percentage = self.patched_cves * 100 / \
                    (total_cves - self.unaffected_cves)

        self.percentage = percentage

    def handle_status_value_change(self, old_value, new_value):
        if old_value == StatusValues['patched']:
            self.patched_cves -= 1

        if old_value == StatusValues['unaffected']:
            self.unaffected_cves -= 1

        if new_value == StatusValues['patched']:
            self.patched_cves += 1

        if new_value == StatusValues['unaffected']:
            self.unaffected_cves += 1

    def get_status(self, cve):
        kernel = self._instance

        try:
            status = Status.objects.get(cve=cve, kernel=kernel,
                    branch=self.name)
        except DoesNotExist:
            status = None

        return status

    def get_status_for_cve_name(self, cve_name):
        cve = Cve.objects.with_id(cve_name)
        if not cve:
            raise DoesNotExistError('CVE "{}" does not exist.'.format(cve_name))

        return self.get_status(cve)

    def update_status(self, status, value):
        Status.validate_value(value)

        if value == status.value:
            return None

        self.handle_status_value_change(status.value, value)

        status.value = value

        return status

    def create_status(self, cve, value):
        Status.validate_value(value)

        if value == StatusValues['unpatched']:
            return None

        kernel = self._instance

        self.handle_status_value_change(None, value)

        status = Status(cve=cve, kernel=kernel, branch=self.name, value=value)

        return status

    def create_status_for_cve_name(self, cve_name, value):
        cve = Cve.objects.with_id(cve_name)
        if not cve:
            raise DoesNotExistError('CVE "{}" does not exist.'.format(cve_name))

        return self.create_status(cve, value)

    def change_status(self, cve_name, value):
        cve = Cve.objects.with_id(cve_name)
        if not cve:
            raise DoesNotExistError('CVE "{}" does not exist.'.format(cve_name))

        status = self.get_status(cve)
        if status:
            status = self.update_status(status, value)
        else:
            status = self.create_status(cve, value)

        return status

    def get_statuses(self, all_statuses=False):
        kernel = self._instance

        cves_list = Status.objects(kernel=kernel, branch=self.name) \
                .only('cve', 'value')
        statuses = {}
        for status in cves_list:
            statuses[status.cve.id] = status.value

        if not all_statuses:
            return statuses

        cves = Cve.objects.scalar('name')
        for cve in cves:
            if cve not in statuses:
                statuses[cve] = StatusValues['unpatched']

        return statuses

class Kernel(Document):
    repo = StringField(required=True, primary_key=True)
    vendor = StringField(required=True)
    device = StringField(required=True)
    deprecated = BooleanField(default=False)
    default_branch = StringField(choices=BranchNames, required=True)
    default_branch_percentage = IntField()
    branches = EmbeddedDocumentListField(Branch, required=True)

    @staticmethod
    def validate_deprecated(v):
        if not isinstance(v, bool):
            raise InvalidTypeError('Kernel deprecated is not a boolean.')

    @staticmethod
    def create(data):
        repo = data.get('repo')
        vendor, device = repo_to_vendor_device(repo)

        deprecated = data.get('deprecated', False)
        Kernel.validate_deprecated(deprecated)

        branches_data = data.get('branches')
        branches = []
        Branch.create_multiple_in(branches_data, branches)

        default_branch = data.get('default_branch')
        Branch.validate_name_in(default_branch, branches)

        try:
            kernel = Kernel.objects.get(vendor=vendor, device=device)
            raise AlreadyExistsError('Kernel "{}" already exists.'.format(repo))
        except AlreadyExistsError as e:
            raise e
        except DoesNotExist:
            pass

        kernel = Kernel(repo=repo, vendor=vendor, device=device,
                deprecated=deprecated, branches=branches,
                default_branch=default_branch)

        return kernel

    def branch_with_name(self, name):
        return Branch.name_in(name, self.branches)

    def validate_branch_with_name(self, name):
        return Branch.validate_name_in(name, self.branches)

    def validate_no_branch_with_name(self, name):
        Branch.validate_name_not_in(name, self.branches)

    def create_branch(self, name, version):
        Branch.create_in(name, version, self.branches)

    def create_branches(self, branches_data):
        Branch.create_multiple_in(branches_data, self.branches)

    def add_branches(self, branches_data):
        branches = []
        Branch.create_multiple_in(branches_data, branches)

        for branch in self.branches:
            Branch.validate_name_in(branch.name, branches)

        for branch in branches:
            if not self.branch_with_name(branch.name):
                self.create_branch(branch.name, branch.version)

    def sort_branches(self):
        self.branches.sort(key=itemgetter('name'))

    def set_percentages(self, total_cves):
        for branch in self.branches:
            branch.set_percentage(total_cves)

        default_branch = self.branch_with_name(self.default_branch)
        self.default_branch_percentage = default_branch.percentage

    def patch(self, data):
        deprecated = data.get('deprecated')
        if deprecated is not None:
            Kernel.validate_deprecated(deprecated)
            self.deprecated = deprecated

        branches_data = data.get('branches')
        if branches_data is not None:
            self.add_branches(branches_data)

        default_branch = data.get('default_branch')
        if default_branch is not None:
            self.validate_branch_with_name(default_branch)
            self.default_branch = default_branch

        return self

class Status(Document):
    value = IntField(required=True, choices=StatusChoices)
    cve = LazyReferenceField(Cve, required=True, reverse_delete_rule=CASCADE)
    kernel = LazyReferenceField(Kernel, required=True, reverse_delete_rule=CASCADE)
    branch = StringField(required=True, choices=BranchNames)

    @staticmethod
    def validate_value(value):
        if value not in StatusChoices:
            raise ValidationError('Status value {} is invalid.'.format(value))

class Log(Document):
    from_data = DictField()
    to_data = DictField()
    author = StringField(required=True)
    date = DateTimeField(required=True, default=datetime.utcnow)

    meta = { 'allow_inheritance': True }

    @classmethod
    def get_page(cls, page, length, **kwargs):
        docs = cls.objects(**kwargs).exclude('id') \
                .skip((page - 1) * length).limit(length)

        pages = int((docs.count() - 1) / length) + 1

        return docs, pages

    def from_doc(self, document):
        self.from_data = value_parse(document)
        self.set_references(document)
        return self

    def to_doc(self, document):
        self.to_data = value_parse(document)
        self.set_references(document)
        pop_common_key_values(self.from_data, self.to_data)
        return self

class CveLogRefs(EmbeddedDocument):
    cve = LazyReferenceField(Cve, required=True)

class CveLog(Log):
    references = EmbeddedDocumentField(CveLogRefs, required=True)

    def set_references(self, document):
        if not isinstance(document, Document):
            return

        self.references = CveLogRefs(cve=document)

class KernelLogRefs(EmbeddedDocument):
    kernel = LazyReferenceField(Kernel, required=True)

class KernelLog(Log):
    references = EmbeddedDocumentField(KernelLogRefs, required=True)

    def set_references(self, document):
        if not isinstance(document, Document):
            return

        self.references = KernelLogRefs(kernel=document)

class StatusLogRefs(EmbeddedDocument):
    kernel = LazyReferenceField(Kernel, required=True)
    branch = StringField(choices=BranchNames, required=True)
    cve = LazyReferenceField(Cve, required=True)

class StatusLog(Log):
    references = EmbeddedDocumentField(StatusLogRefs, required=True)

    def set_references(self, document):
        if not isinstance(document, Document):
            return

        self.references = StatusLogRefs(kernel=document.kernel, \
                branch=document.branch, cve=document.cve)
