from mongoengine import *
from utils import *

StatusChoices = [1, 2, 3, 4, 5, 6]
StatusDescriptions = {
    1: 'unpatched',
    2: 'patched',
    3: 'unaffected',
    4: 'upstream hold',
    5: 'on gerrit',
    6: 'update available'
}
StatusValues = {
    'unpatched': 1,
    'patched': 2,
    'unaffected': 3,
    'upstream hold': 4,
    'on gerrit': 5,
    'update available': 6
}

BranchNames = ['cm-13.0', 'cm-14.1', 'lineage-15.0']
KernelVersions = ['3.4', '3.10', '3.18', '4.4', '4.9']

DeprecatedMap = {
    -1: [True, False],
    0: [False],
    1: [True]
}

def map_deprecated_values(v):
    if type(v) in [unicode, str]:
        try:
            deprecated = int(v)
        except ValueError:
            deprecated = None
    else:
        deprecated = v

    if deprecated not in DeprecatedMap:
        deprecated = -1

    return DeprecatedMap[deprecated]

class Patchset(EmbeddedDocument):
    versions = ListField(StringField(choices=KernelVersions), required=True)
    patches = ListField(StringField(), required=True)

    @staticmethod
    def is_valid_versions(versions):
        if not versions:
            return False
        for version in versions:
            if version not in KernelVersions:
                return False
        return True

    @staticmethod
    def is_valid_patches(patches):
        if not patches:
            return False
        for patch in patches:
            if not is_valid_url(patch):
                return False
        return True

class Cve(Document):
    name = StringField(required=True, primary_key=True)
    notes = StringField(default='')
    score = IntField(min_value=0, max_value=10, required=True)
    tags = ListField(StringField(), default=[])
    patchsets = EmbeddedDocumentListField(Patchset, default=[])

    @staticmethod
    def is_valid_name(name):
        if not name:
            return False
        if type(name) not in [unicode, str]:
            return False
        if name[:3] not in ['CVE', 'LVT']:
            return False
        return True

    @staticmethod
    def is_valid_notes(notes):
        if type(notes) is not str:
            return False
        return True

    @staticmethod
    def is_valid_score(score):
        return score >= 0 and score <= 10

    @staticmethod
    def is_valid_tags(tags):
        if type(tags) is not list:
            return False
        for tag in tags:
            if type(tag) not in [unicode, str]:
                return False
        return True

class Branch(EmbeddedDocument):
    name = StringField(required=True, choices=BranchNames)
    version = StringField(required=True, choices=KernelVersions)
    patched_cves = IntField(default=0)
    unaffected_cves = IntField(default=0)

class Kernel(Document):
    repo = StringField(required=True, primary_key=True)
    vendor = StringField(required=True)
    device = StringField(required=True)
    deprecated = BooleanField(default=False)
    default_branch = StringField(choices=BranchNames, required=True)
    branches = EmbeddedDocumentListField(Branch, required=True)

    @staticmethod
    def is_valid_deprecated(v):
        return type(v) is bool

    @staticmethod
    def is_valid_branch(name):
        return name in BranchNames

    @staticmethod
    def branch_with_name_in(name, branches):
        found_branch = None
        for branch in branches:
            if name == branch.name:
                found_branch = branch
        return found_branch

    @staticmethod
    def is_valid_version(version):
        return version in KernelVersions

    @staticmethod
    def create_branch_in(name, version, branches):
        if not Kernel.is_valid_branch(name):
            raise ValueError('Branch name is invalid.')

        if Kernel.branch_with_name_in(name, branches):
            raise ValueError('Branch name is duplicated.')

        if not Kernel.is_valid_version(version):
            raise ValueError('Branch version is invalid.')

        branch = Branch(name=name, version=version)
        branches.append(branch)

    def branch_with_name(self, name):
        return self.branch_with_name_in(name, self.branches)

    def create_branch(self, name, version):
        self.create_branch_in(name, version, self.branches)

class Status(Document):
    value = IntField(required=True, choices=StatusChoices)
    cve = ReferenceField(Cve, required=True, reverse_delete_rule=CASCADE)
    kernel = ReferenceField(Kernel, required=True, reverse_delete_rule=CASCADE)
    branch = StringField(required=True, choices=BranchNames)

    @staticmethod
    def is_valid_value(value):
        return value in StatusChoices
