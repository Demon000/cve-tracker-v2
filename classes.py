from mongoengine import *
from utils import *

StatusChoices = [1, 2, 3, 4, 5, 6]
StatusDescriptions = {
    1: 'unpatched',
    2: 'patched',
    3: 'unaffected',
    4: 'upstream hold',
    5: 'on gerrit',
    6: 'update available'
}
StatusValues = {
    'unpatched': 1,
    'patched': 2,
    'unaffected': 3,
    'upstream hold': 4,
    'on gerrit': 5,
    'update available': 6
}

BranchNames = ['cm-13.0', 'cm-14.1', 'lineage-15.0']
KernelVersions = ['3.4', '3.10', '3.18', '4.4', '4.9']

DeprecatedMap = {
    -1: [True, False],
    0: [False],
    1: [True]
}

def map_deprecated_values(v):
    if type(v) in [unicode, str]:
        try:
            deprecated = int(v)
        except ValueError:
            deprecated = None
    else:
        deprecated = v

    if deprecated not in DeprecatedMap:
        deprecated = -1

    return DeprecatedMap[deprecated]

class Patchset(EmbeddedDocument):
    versions = ListField(StringField(choices=KernelVersions), required=True)
    patches = ListField(StringField(), required=True)

    @staticmethod
    def is_valid_versions(versions):
        if not versions:
            return False
        for version in versions:
            if version not in KernelVersions:
                return False
        return True

    @staticmethod
    def is_valid_patches(patches):
        if not patches:
            return False
        for patch in patches:
            if not is_valid_url(patch):
                return False
        return True

    @staticmethod
    def create(data):
        versions = data.get('versions')
        if not Patchset.is_valid_versions(versions):
            raise ValueError('Patchset versions are invalid.')

        patches = data.get('patches')
        if not Patchset.is_valid_patches(patches):
            raise ValueError('Patchset patches are invalid.')

        patchset = Patchset(versions=versions, patches=patches)

        return patchset

class Cve(Document):
    name = StringField(required=True, primary_key=True)
    notes = StringField(default='')
    score = FloatField(min_value=0, max_value=10, required=True)
    tags = ListField(StringField(), default=[])
    patchsets = EmbeddedDocumentListField(Patchset, required=True)

    @staticmethod
    def is_valid_name(name):
        if not name:
            return False
        if type(name) not in [unicode, str]:
            return False
        if name[:3] not in ['CVE', 'LVT']:
            return False
        return True

    @staticmethod
    def is_valid_notes(notes):
        if type(notes) not in [unicode, str]:
            return False
        return True

    @staticmethod
    def is_valid_score(score):
        if type(score) not in [float, int]:
            return False
        return score >= 0 and score <= 10

    @staticmethod
    def is_valid_tags(tags):
        if type(tags) is not list:
            return False
        for tag in tags:
            if type(tag) not in [unicode, str]:
                return False
        return True

    @staticmethod
    def create(data):
        name = data.get('name')
        if not Cve.is_valid_name(name):
            raise ValueError('CVE name is invalid.')

        notes = data.get('notes', '')
        if not Cve.is_valid_notes(notes):
            raise ValueError('CVE notes are invalid.')

        score = data.get('score')
        if not Cve.is_valid_score(score):
            raise ValueError('CVE score must be a number between 0 and 10.')

        tags = data.get('tags', [])
        if not Cve.is_valid_tags(tags):
            raise ValueError('CVE tags are invalid.')

        patchsets_data = data.get('patchsets')
        patchsets = []
        for patchset_data in patchsets_data:
            try:
                patchset = Patchset.create(patchset_data)
            except ValueError as e:
                raise e

            patchsets.append(patchset)

        try:
            cve = Cve.objects.get(name=name)
            raise ValueError('CVE already exists.')
        except ValueError as e:
            raise e
        except DoesNotExist:
            pass

        cve = Cve(name=name, notes=notes, score=score, tags=tags,
                patchsets=patchsets)

        return cve

    def patch(self, data):
        notes = data.get('notes')
        if notes is not None:
            if Cve.is_valid_notes(notes):
                self.notes = notes
            else:
                raise ValueError('CVE notes are invalid.')

        score = data.get('score')
        if score is not None:
            if Cve.is_valid_score(score):
                self.score = score
            else:
                raise ValueError('CVE score must be a number between 0 and 10.')

        tags = data.get('tags')
        if tags is not None:
            if Cve.is_valid_tags(tags):
                self.tags = tags
            else:
                raise ValueError('CVE tags are invalid.')

        patchsets_data = data.get('patchsets')
        if patchsets_data is not None:
            patchsets = []
            for patchset_data in patchsets_data:
                try:
                    patchset = Patchset.create(patchset_data)
                except ValueError as e:
                    raise e

                patchsets.append(patchset)

            self.patchsets = patchsets

        return self

class Branch(EmbeddedDocument):
    name = StringField(required=True, choices=BranchNames)
    version = StringField(required=True, choices=KernelVersions)
    patched_cves = IntField(default=0)
    unaffected_cves = IntField(default=0)
    percentage = IntField()

    def set_percentage(self, total_cves):
        if self.unaffected_cves == total_cves:
            percentage = 0
        else:
            percentage = self.patched_cves / \
                    (total_cves - self.unaffected_cves) * 100

        self.percentage = percentage

class Kernel(Document):
    repo = StringField(required=True, primary_key=True)
    vendor = StringField(required=True)
    device = StringField(required=True)
    deprecated = BooleanField(default=False)
    default_branch = StringField(choices=BranchNames, required=True)
    default_branch_percentage = IntField()
    branches = EmbeddedDocumentListField(Branch, required=True)

    @staticmethod
    def is_valid_deprecated(v):
        return type(v) is bool

    @staticmethod
    def is_valid_branch(name):
        return name in BranchNames

    @staticmethod
    def branch_with_name_in(name, branches):
        found_branch = None
        for branch in branches:
            if name == branch.name:
                found_branch = branch
        return found_branch

    @staticmethod
    def is_valid_version(version):
        return version in KernelVersions

    @staticmethod
    def create_branch_in(name, version, branches):
        if not Kernel.is_valid_branch(name):
            raise ValueError('Branch name is invalid.')

        if Kernel.branch_with_name_in(name, branches):
            raise ValueError('Branch name is duplicated.')

        if not Kernel.is_valid_version(version):
            raise ValueError('Branch version is invalid.')

        branch = Branch(name=name, version=version)
        branches.append(branch)

    @staticmethod
    def create_branches_in(branches_data, branches):
        for branch_data in branches_data:
            name = branch_data.get('name')
            version = branch_data.get('version')
            Kernel.create_branch_in(name, version, branches)

    @staticmethod
    def create(data):
        repo = data.get('repo')
        try:
            vendor, device = repo_to_vendor_device(repo)
        except ValueError as e:
            raise e

        deprecated = data.get('deprecated', False)
        if not Kernel.is_valid_deprecated(deprecated):
            raise ValueError('Kernel deprecation is invalid.')

        branches_data = data.get('branches')
        try:
            branches = []
            Kernel.create_branches_in(branches_data, branches)
        except ValueError as e:
            raise e

        default_branch = data.get('default_branch')
        if not Kernel.branch_with_name_in(default_branch, branches):
            raise ValueError('Kernel default branch is invalid.')

        try:
            kernel = Kernel.objects.get(vendor=vendor, device=device)
            raise ValueError('Kernel already exists.')
        except ValueError as e:
            raise e
        except DoesNotExist:
            pass

        kernel = Kernel(repo=repo, vendor=vendor, device=device,
                deprecated=deprecated, branches=branches,
                default_branch=default_branch)

        return kernel

    def branch_with_name(self, name):
        return Kernel.branch_with_name_in(name, self.branches)

    def create_branch(self, name, version):
        Kernel.create_branch_in(name, version, self.branches)

    def create_branches(self, branches_data):
        Kernel.create_branches_in(branches_data, self.branches)

    def set_percentages(self, total_cves):
        for branch in self.branches:
            branch.set_percentage(total_cves)

        default_branch = self.branch_with_name(self.default_branch)
        self.default_branch_percentage = default_branch.percentage

    def patch(self, data):
        deprecated = data.get('deprecated')
        if deprecated is not None:
            if Kernel.is_valid_deprecated(deprecated):
                self.deprecated = deprecated
            else:
                raise ValueError('Kernel deprecation is invalid.')

        branches_data = data.get('branches')
        if branches_data is not None:
            try:
                self.create_branches(branches_data)
            except ValueError as e:
                raise e

        default_branch = data.get('default_branch')
        if default_branch is not None:
            if self.branch_with_name(default_branch):
                self.default_branch = default_branch
            else:
                raise ValueError('Kernel default branch is invalid.')

        return self

class Status(Document):
    value = IntField(required=True, choices=StatusChoices)
    cve = ReferenceField(Cve, required=True, reverse_delete_rule=CASCADE)
    kernel = ReferenceField(Kernel, required=True, reverse_delete_rule=CASCADE)
    branch = StringField(required=True, choices=BranchNames)

    @staticmethod
    def is_valid_value(value):
        return value in StatusChoices
