import traceback

from flask import Blueprint, jsonify, request
from classes import *
from utils import *

api_v1 = Blueprint('api_v1', __name__, url_prefix='/api/v1')

@api_v1.route('/status_descriptions', methods=['GET'])
def get_statuses():
    return json_response_success({
        'message': 'Status descriptions have been successfully retrieved.',
        'data': StatusDescriptions
    }, 200)

@api_v1.route('/kernel_versions', methods=['GET'])
def get_kernel_versions():
    return json_response_success({
        'message': 'Kernel versions have been successfully retrieved.',
        'data': KernelVersions
    }, 200)

@api_v1.route('/branch_names', methods=['GET'])
def get_branch_names():
    return json_response_success({
        'message': 'Branch names have been successfully retrieved.',
        'data': BranchNames
    }, 200)

@api_v1.route('/kernels', methods=['GET'])
def get_kernels():
    deprecated = request.args.get('deprecated')
    deprecated_values = map_deprecated_values(deprecated)

    kernels = Kernel.objects(deprecated__in=deprecated_values)

    cves_count = Cve.objects.count()
    for kernel in kernels:
        kernel.set_percentages(cves_count)

    return json_response_success({
        'message': 'Kernels have been successfully retrieved.',
        'count': kernels.count(),
        'data': kernels
    }, 200)

@api_v1.route('/kernels/<repo>', methods=['GET'])
def get_kernel(repo):
    kernel = Kernel.objects.with_id(repo)
    if not kernel:
        return json_response_error({
            'message': 'Kernel does not exist.'
        }, 400)

    cves_count = Cve.objects.count()
    kernel.set_percentages(cves_count)

    return json_response_success({
        'message': 'Kernels have been successfully retrieved.',
        'data': kernel
    }, 200)

@api_v1.route('/kernels', methods=['POST'])
def post_kernels():
    request_data = request.get_json()

    if type(request_data) is not dict:
        return json_response_error({
            'message': 'Request body is not an object.'
        }, 400)

    try:
        kernel = Kernel.create(request_data).save()
    except ValueError as e:
        return json_response_error({
            'message': str(e)
        }, 400)

    return json_response_success({
        'message': 'Kernel has been successfully added.',
        'data': kernel
    }, 200)

@api_v1.route('/kernels/<repo>', methods=['PATCH'])
def patch_kernel(repo):
    request_data = request.get_json()

    if type(request_data) is not dict:
        return json_response_error({
            'message': 'Request body is not an object.'
        }, 400)

    kernel = Kernel.objects.with_id(repo)
    if not kernel:
        return json_response_error({
            'message': 'Kernel does not exist.'
        }, 400)

    deprecated = request_data.get('deprecated')
    if deprecated is not None:
        if Kernel.is_valid_deprecated(deprecated):
            kernel.deprecated = deprecated
        else:
            return json_response_error({
                'message': 'Kernel deprecation is invalid.'
            }, 400)

    branches_data = request_data.get('branches')
    if branches_data is not None:
        try:
            kernel.create_branches(branches_data)
        except ValueError as e:
            return json_response_error({
                'message': str(e)
            }, 400)

    default_branch = request_data.get('default_branch')
    if default_branch is not None:
        if kernel.branch_with_name(default_branch):
            kernel.default_branch = default_branch
        else:
            return json_response_error({
                'message': 'Kernel default branch is invalid.'
            }, 400)

    kernel.save()

    return json_response_success({
        'message': 'Kernel has been successfully updated.',
        'data': kernel
    }, 200)

@api_v1.route('/kernels/<repo>/branches/<branch_name>/statuses',
        methods=['GET'])
def get_kernel_branch_statuses(repo, branch_name):
    kernel = Kernel.objects.with_id(repo)
    if not kernel:
        return json_response_error({
            'message': 'Kernel does not exist.'
        }, 400)

    if not kernel.branch_with_name(branch_name):
        return json_response_error({
            'message': 'Branch does not exist.'
        }, 400)

    statuses = Status.objects(kernel=kernel, branch=branch_name) \
            .no_dereference().exclude('id')

    return json_response_success({
        'message': 'Statuses have been successfully retrieved.',
        'data': statuses
    }, 200)

@api_v1.route('/kernels/<repo>/branches/<branch_name>/statuses',
        methods=['POST'])
def post_kernel_branch_statuses(repo, branch_name):
    request_data = request.get_json()

    if type(request_data) is not dict:
        return json_response_error({
            'message': 'Request body is not an object.'
        }, 400)

    kernel = Kernel.objects.with_id(repo)
    if not kernel:
        return json_response_error({
            'message': 'Kernel does not exist.'
        }, 400)

    branch = kernel.branch_with_name(branch_name)
    if not branch:
        return json_response_error({
            'message': 'Branch does not exist.'
        }, 400)

    value = request_data.get('value')
    if not Status.is_valid_value(value):
        return json_response_error({
            'message': 'Status value is invalid.'
        }, 400)

    cve_names = request_data.get('cves')
    if not cve_names:
        return json_response_error({
            'message': 'CVEs cannot be empty.'
        }, 400)

    statuses = []
    for cve_name in cve_names:
        cve = Cve.objects.with_id(cve_name)
        if not cve:
            return json_response_error({
                'message': 'CVE does not exist.'
            }, 400)

        try:
            status = Status.objects.get(cve=cve, kernel=kernel,
                    branch=branch_name)

            if status.value == value:
                continue

            if status.value == StatusValues['patched']:
                branch.patched_cves -= 1

            if status.value == StatusValues['unaffected']:
                branch.unaffected_cves += 1

            status.value = value
        except DoesNotExist:
            status = Status(cve=cve, kernel=kernel,
                    branch=branch_name, value=value)

        if status.value == StatusValues['patched']:
            branch.patched_cves += 1

        if status.value == StatusValues['unaffected']:
            branch.unaffected_cves += 1

        statuses.append(status)

    for status in statuses:
        status.save()

    kernel.save()

    return json_response_success({
        'message': 'Stauses have been successfully updated.'
    }, 200)

@api_v1.route('/kernels/<repo>', methods=['DELETE'])
def delete_kernel(repo):
    kernel = Kernel.objects.with_id(repo)
    if not kernel:
        return json_response_error({
            'message': 'Kernel does not exist.'
        }, 400)

    kernel.delete()

    return json_response_success({
        'message': 'Kernel has been successfully deleted.',
        'data': kernel
    }, 200)

@api_v1.route('/cves', methods=['GET'])
def get_cves():
    cves = Cve.objects()

    return json_response_success({
        'message': 'CVEs have been successfully retrieved.',
        'count': cves.count(),
        'data': cves
    }, 200)

@api_v1.route('/cves', methods=['POST'])
def post_cves():
    request_data = request.get_json()

    if type(request_data) is not dict:
        return json_response_error({
            'message': 'Request body is not an object.'
        }, 400)

    name = request_data.get('name')
    if not Cve.is_valid_name(name):
        return json_response_error({
            'message': 'CVE name is invalid.'
        }, 400)

    notes = request_data.get('notes')
    if notes is not None:
        if not Cve.is_valid_notes(notes):
            return json_response_error({
                'message': 'CVE notes are invalid.'
            }, 400)
    else:
        notes = ''

    score = request_data.get('score')
    if not Cve.is_valid_score(score):
        return json_response_error({
            'message': 'CVE score must be between 0 and 10.'
        }, 400)

    tags = request_data.get('tags')
    if tags is not None:
        if not Cve.is_valid_tags(tags):
            return json_response_error({
                'message': 'CVE tags are invalid.'
            }, 400)
    else:
        tags = []

    cve = Cve.objects.with_id(name)
    if cve:
        return json_response_error({
            'message': 'CVE already exists.'
        }, 400)
    else:
        cve = Cve(name=name, notes=notes, score=score, tags=tags)

    cve.save()

    return json_response_success({
        'message': 'CVE has been successfully added.',
        'data': cve
    }, 200)

@api_v1.route('/cves/<name>', methods=['PATCH'])
def patch_cve(name):
    request_data = request.get_json()

    if type(request_data) is not dict:
        return json_response_error({
            'message': 'Request body is not an object.'
        }, 400)

    cve = Cve.objects.with_id(name)
    if not cve:
        return json_response_error({
            'message': 'CVE does not exist.'
        }, 400)

    notes = request_data.get('notes')
    if notes is not None:
        if Cve.is_valid_notes(notes):
            cve.notes = notes
        else:
            return json_response_error({
                'message': 'CVE notes are invalid.'
            }, 400)

    score = request_data.get('score')
    if score is not None:
        if Cve.is_valid_score(score):
            cve.score = score
        else:
            return json_response_error({
                'message': 'CVE score must be between 0 and 10.'
            }, 400)

    tags = request_data.get('tags')
    if tags is not None:
        if Cve.is_valid_tags(tags):
            cve.tags = tags
        else:
            return json_response_error({
                'message': 'CVE tags are invalid.'
            }, 400)

    cve.save()

    return json_response_success({
        'message': 'CVE has been successfully updated.',
        'data': cve
    }, 200)

@api_v1.route('/cves/<name>/statuses', methods=['GET'])
def get_cve_statuses(name):
    cve = Cve.objects.with_id(name)
    if not cve:
        return json_response_error({
            'message': 'CVE does not exist.'
        }, 400)

    statuses = Status.objects(cve=cve)

    return json_response_success({
        'message': 'Statuses have been successfully retrieved.',
        'data': statuses
    }, 200)

@api_v1.route('/cves/<name>/patchsets', methods=['PUT'])
def put_cve_patchsets(name):
    request_data = request.get_json()

    if type(request_data) is not list:
        return json_response_error({
            'message': 'Request body is not an array.'
        }, 400)

    cve = Cve.objects.with_id(name)
    if not cve:
        return json_response_error({
            'message': 'CVE does not exist.'
        }, 400)

    patchsets = []
    for patchset_data in request_data:
        versions = patchset_data.get('versions')
        if not Patchset.is_valid_versions(versions):
            return json_response_error({
                'message': 'Patchset versions are invalid.'
            }, 400)

        patches = patchset_data.get('patches')
        if not Patchset.is_valid_patches(patches):
            return json_response_error({
                'message': 'Patchset patches are invalid.'
            }, 400)

        patchset = Patchset(versions=versions, patches=patches)
        patchsets.append(patchset)

    cve.patchsets = patchsets
    cve.save()

    return json_response_success({
        'message': 'Patchsets have been successfully updated.',
        'data': cve
    }, 200)

@api_v1.route('/cves/<name>', methods=['DELETE'])
def delete_cve(name):
    cve = Cve.objects.with_id(name)
    if not cve:
        return json_response_error({
            'message': 'CVE does not exist.'
        }, 400)

    cve.delete()

    return json_response_success({
        'message': 'CVE has been successfully deleted.',
        'data': cve
    }, 200)

@api_v1.errorhandler(Exception)
def error_handler(e):
    message = traceback.format_exc()
    return json_response_error({
        'message': message
    }, 500)
